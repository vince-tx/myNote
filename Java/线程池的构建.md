# 线程池的构建（参数介绍和简单场景示例）

Executors提供了几种线程池的工厂方法，也可以使用ThreadPoolExecutor进行自定义的线程池构建。

JDK文档如下介绍：
 > When a new task is submitted in method     {@link #execute(Runnable)},
  and fewer than corePoolSize threads are running, a new thread is
  created to handle the request, even if other worker threads are
  idle.  If there are more than corePoolSize but less than
  maximumPoolSize threads running, a new thread will be created only
  if the queue is full.  By setting corePoolSize and maximumPoolSize
  the same, you create a fixed-size thread pool. By setting
  maximumPoolSize to an essentially unbounded value such as {@code
  Integer.MAX_VALUE}, you allow the pool to accommodate an arbitrary
  number of concurrent tasks. Most typically, core and maximum pool
  sizes are set only upon construction, but they may also be changed
  dynamically using {@link #setCorePoolSize} and {@link #setMaximumPoolSize}. <br> <br>
  当新任务提交时，此时若少于核心线程数的线程正在运行，将会创建一个新的线程去处理请求,即使还有其他空闲的工作线程。如果当前运行线程数大于核心线程数但小于最大线程数，只有当任务队列满了时才会创建新线程来处理请求。你可以设置相同的核心线程数和最大线程数来创建一个固定大小的线程池，也可以设置一个无界的最大线程数(eg. Integer.MAX_VALUE)来创建一个容纳任意个并发任务的线程池。最典型的是，核心线程大小和最大线程大小只能在构造时设置，但是也可以使用setCorePoolSize 和 setMaximumPoolSize动态地改变。
  

## 参数介绍
    public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory,
    RejectedExecutionHandler handler)

### 1. corePoolSize
### 2. maximumPoolSize
### 3. keepAliveTime
### 4. unit
### 5. workQueue
### 6. threadFactory
### 7. handler
